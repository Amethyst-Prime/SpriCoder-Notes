Lec-2 软件过程的历史演变和经典工作
---

# 1. 再读《没有银弹》
1. 软件开发有很多困难，但是本质难题是
   1. 不可见性：软件项目是一个逻辑实体
   2. 复杂性：实体数量众多
   3. 可变性
   4. 一致性
2. 进一步分析
   1. 三个本质难题因项目而异
   2. 四大本质难题相互促进
   3. 本质难题变化带动软件方法（过程）演变
3. 本质难题无法彻底解决

# 2. 软件发展三大阶段
![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/lec2/1.jpg)

1. 软硬件一体化阶段（50年代~70年代）
   1. 软件完全依附于硬件
   2. 软件作坊
2. 软件成为独立的产品（70年代~90年代）
3. 网络化和服务化（90年代中期迄今）

## 2.1. 软件完全依附于硬件

### 2.1.1. 典型特征
1. 软件应用典型特征
   1. 软件支持硬件完成计算任务
   2. 功能单一
   3. 复杂度有限
   4. 几乎不需要需求变更
2. 软件开发典型特征
   1. 硬件太贵
   2. 团队以硬件工程师和数学家为主

### 2.1.2. 典型软件过程和实践
1. Measure twice, cut once，相同的软件工程实践：code review & inspection

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/lec2/2.jpg)

1. specification和参数、代码等部分相关

## 2.2. 软件作坊

### 2.2.1. 典型特征
1. 软件应用典型特征
   1. 功能简单
   2. 规模小
2. 软件开发典型特征
   1. 很多非专业领域的人员涌入软件开发领域
   2. 高级程序语言出现
   3. 质疑权威文化盛行

### 2.2.2. 典型软件过程和实践
1. Code And Fix
2. 软件危机和软件工程：Code And Fix不适合大型软件项目开发

## 2.3. 软件成为独立产品

### 2.3.1. 典型特征
1. 软件应用特征
   1. 摆脱了硬件束缚（OS）
   2. 功能强大
   3. 规模和复杂度剧增
   4. 个人电脑出现 => 普通人成为软件用户
      1. 需求多变
      2. 兼容性要求
   5. 来自市场的压力

### 2.3.2. 软件典型过程和实践
1. 方法之一：形式化方法
2. 方法之二：结构化设计和瀑布模型

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/lec2/3.jpg)

3. 右侧不是生命周期模型
4. 瀑布模型是左侧的部分：每个阶段都有一个往回的箭头
5. 生命周期模型
   1. 是什么：一个对软件过程的人为划分
   2. 主要作用：便于传达，复制成功
6. 说法是错误的：lean development说：其实royee提出瀑布生命周期模型的本意是该生命周期模型不适合软件开发
7. royee
   1. 本意是瀑布模型不是一个单一的生命周期模型，是很多的元素的融合，是系列的生命周期模型，包括编码改错、改进等等。
   2. 软件团队在选择生命周期模型时，应当结合上下文选择生命周期模型，往往越复杂，有越多的元素，自己选择最合适的。
   3. 大部分的项目团队轻视了项目的复杂和挑战，选择了一个简单的不适用的瀑布模型。
8. 问题和不足(效率和质量)
   1. 形式化存在扩展性和可用性方面存在不足
   2. 瀑布模型成为一个重文档，慢节奏的过程。

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/lec2/4.jpg)

4. 成熟度模型（最开始是CMM，现在是CMMI）
   1. 什么是有管理的：状态获取？
   2. 管理的是三个要素：目标、状态和纠偏
   3. CMMI的3级中的标准化目的不是简单的替换
   4. CMMI从2级升级到3级的原因：固化最佳实践，对小组而言则是能够更快地学习其他的做法
   5. CMMI 3级的重点是已定义
   6. CMMI 4级我们希望能够看到一个预测模型
   7. 4级和5级更多是根据结果（未来）来进行管理
   8. 2级和3级关注的是当前的状态

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/lec2/5.jpg)

5. 分级
   1. 第一级：初始级别
   2. 第二级：和项目有关
   3. 第三级：促成共享，来自于团队标准
   4. 第四级：定量管理，提升对未来结果的一种预测，对偏差的预测
6. 一些讨论：https://www.jianshu.com/p/b7407257eedb
   1. CMMI是过程改进模型而非软件过程或者软件过程模型，说法怎么样？对的，CMMI指导软件过程改进，不指导开发。
   2. CMMI不是过程优劣的标准，也不适合用作公司之间的能力比较，说法怎么样？对的，CMMI本身是有评级。（美国国防部订单招标要求企业至少达到CMMI的3级。因为公司的能力需要绝对东西，也就是能力强，能力弱，而CMMI衡量的是相对的水平，CMMI仅仅关注在本公司的目标下的等级
   3. 为什么CMMI VS. Agile是一个伪命题？

## 2.4. 网络化和服务化

### 2.4.1. 典型特征
1. 软件应用特征
   1. 功能更复杂，规模更大
   2. 用户数量急剧增加（这会带来什么问题？）
   3. 快速演化和需求不确定
   4. 分发方式的变化（SaaS）

### 2.4.2. 典型软件过程和实践
1. 迭代式：**大型软件系统的开发过程也是一个逐步学习和交流的过程，软件系统的交付不是一次完成，而是通过多个迭代周期，逐步来完成交付。**
2. 雪鸟会议和敏捷宣言
   1. 个体和互动胜过流程和工具
   2. 可以工作的软件胜过详尽的文档
   3. 客户合作胜过合同谈判
   4. 响应变化胜过遵循计划
3. 也就是说，**尽管右项有其价值，我们更重视左项的价值**。
4. 请务必关注最后一句话，非常重要

![](https://spricoder.oss-cn-shanghai.aliyuncs.com/2021-software-quality-management/img/lec2/6.jpg)

4. XP（eXtreme Programing） 方法
   1. 偏重于一些工程实践的描述
5. SCRUM
   1. 管理框架和管理实践
6. Kanban
   1. 精益生产（丰田制造法）的具体实现
   2. 可视化工作流、限定WIP、管理周期时间
   3. 马丁提出了微服务架构
7. 开源软件开发方法：是一种基于并行开发模式的软件开发的组织与管理方式 
   1. Linus 定律：如果有足够多的beta测试者和合作开发者，几乎所有问题都会很快显现，然后自然有人会把它解决。
   2. 早发布，常发布，倾听用户的反馈 、把你的用户当成开发合作者对待，如果想让代码质量快速提升并有效排错，这是最省心的途径、设计上的完美不是没有东西可以再加，而是没有东西可以再减
   3. 代码管理：严格的代码提交社区审核制度 
8. 一些演化
   1. 内部开源（inner source）
   2. 众包(Crowdsourcing)

# 3. 当前软件发展现状
1. 软件应用典型特征
   1. 进一步服务化和网络化(移动是主流)
   2. 用户需求多样化进一步凸显
   3. 软件产品和服务的地位变化
   4. 错综复杂的部署环境
2. 近乎苛刻的用户期望
   1. 多：功能丰富，个性化
   2. 快：快速使用，及时更新，快速解决问题
   3. 好：稳定，可靠，安全，可信
   4. 省：用户的获得成本低，最好免费
3. 空前强大的开发和部署环境——XaaS
   1. IaaS
   2. PaaS
   3. SaaS, FaaS
4. 盛行共享和开源
5. 潜在支撑获得了长足进步（AI，Bigdata， Cloud，etc.）

# 4. 典型DevOps实践和方法
1. 方法论基础是敏捷软件开发、精益思想以及看板Kanban方法。
2. 以领域驱动设计为指导的微服务架构方式
3. 大量虚拟化技术的使用
4. 一切皆服务XaaS(X as a Service)的理念指导
5. 构建了强大的工具链，支持高水平自动化

# 5. 课程小论文
1. 从软件发展的三大历史阶段以及软件过程的演变当中，我们可以总结出哪些规律性的东西？

